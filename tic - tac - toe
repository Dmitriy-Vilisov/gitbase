import random


# БЛОК ПРИВЕТСТВИЯ игрока(ов)
def introduction(func):
    def wrapper():
        print("\t\t Приветствуем вас  ")
        print("\t\t     в игре        ")
        print("\t\t крестики-нолики   ")
        func()
    return wrapper


@introduction
def start():    # БЛОК ВВОДА стартовой информации
    while True:
        print("Какой режим выберете?")
        mode = input(f"\n1. Игра против суперинтелекта\n2. Игра против человека\n")
        try:
            mode = int(mode)
        except ValueError:
            print("Некорректный ввод. Повторите пожалуйста")
            continue
        mode = int(mode)
        if mode > 2 or mode < 1:
            print("Некорректный ввод. Повторите пожалуйста")
            continue
        break
    return main(mode)


# БЛОК ВЫБОРА НАСТРОЕК игры
def main(mode):
    board = list(range(1, 10))
    if mode == 2:
        return pvp_for_xo(board)
    else:
        return pve_for_xo(board)


# БЛОК УПРАВЛЕНИЯ игрой с человеком
def pvp_for_xo(board):
    _counter = 0
    win = False
    while not win:
        outline(board)
        if _counter % 2 == 0:
            play_mark("X", board)
        else:
            play_mark("O", board)
        _counter += 1
        if _counter > 4:
            tmp = check_win(board)
            if tmp:
                print(tmp, "выиграл!")
                break
        if _counter == 9:
            print("Ничья!")
            break
    return new_game()


# БЛОК УПРАВЛЕНИЯ игрой с компьютером
def pve_for_xo(board):
    _counter = 0
    win = False
    while True:
        pl_xo = input(f"Выберите:\n1. крестик\n2. нолик")
        try:
            pl_xo = int(pl_xo)
        except ValueError:
            print("Некорректный ввод. Повторите пожалуйста")
            continue
        pl_xo = int(pl_xo) - 1
        if pl_xo > 1 or pl_xo < -1:
            print('Некорректный ввод. Повторите пожалуйста')
            continue
        break
    while not win:
        outline(board)
        if pl_xo == 0:
            if _counter % 2 == 0:  # если человек выбрал Х и ход четный(+ нулевой)
                play_mark("X", board)   # то человек ставит Х
            else:
                ai_xo(board, "X")  # В Блок вычисления хода Ai передается "X"
        else:
            if _counter % 2 == 0:  # если человек выбрал 0 и ход нечетный
                ai_xo(board, "O")  # ход AI(X)
            else:
                play_mark("O", board)  # иначе ходит человек
        _counter += 1
        if _counter > 4:
            tmp = check_win(board)
            if tmp:
                print(tmp, "выиграл!")
                break
        if _counter == 9:
            print("Ничья!")
            break
    return new_game()


# БЛОК ОТРИСОВКИ игровой матрицы и оформления
def outline(board):
    if len(board) == 9:
        print("-" * 13)
        for i in range(3):
            print("]", board[0+i*3], "|", board[1+i*3], "|", board[2+i*3], "[")
        print("-" * 13)


# БЛОК ИЗМЕНЕНИЯ значений игровой матрицы(board)
def play_mark(mark, board):
    _choice = False
    while not _choice:
        if type(mark) != list:  # Если передана строка, значит ход человека. Нужно спросить куда. Если Список -- AI
            answer = input(f"   Ход {mark}!  ")
            try:
                answer = int(answer)
            except ValueError:
                print("Ошибка ввода. Повторите пожалуйста")
                continue
        else:
            answer = mark[0]
            mark = mark[1]
        answer = int(answer)
        if 1 <= answer <= 9:
            if str(board[answer - 1]) not in "XO":
                board[answer-1] = mark
                _choice = True
            else:
                print("Клетка занята")
        else:
            print("Ошибка ввода. Повторите пожалуйста")


# БЛОК ВЫЧИСЛЕНИЯ ХОДА Ai
def ai_xo(board, pl_xo):   # X_or_O = X => Ai = O
    perception = [board[i:i + 3] for i in range(0, len(board), 3)]
    horizontal = perception.copy()
    vertical = perception.copy()
    # Формируем список позиций, в которых Ai должен сделать вынужденный ход(X,X,О! - защита; O,O,О! - победа)
    # [[123],[..][..]], если есть pl_xo вместо числа -- удаляем. Оцениваем по длине списка и кол-вy знаков AI
    horizontal_ = [[f for f in element if f != pl_xo] for i, element in enumerate(horizontal)]  # [[.],[.],[.],[.].... ]
    vertical_ = [list(reversed(col)) for col in zip(*vertical)]           # Источник № 2. Поворот матрицы на 90 градусов
    vertical_ = [[f for f in element if f != pl_xo] for i, element in enumerate(vertical_)]  # -//-
    diagonal_board = [board[0], board[4], board[8], board[2], board[4], board[6]]  # создаем 2 подсписка для диагоналей
    perception_diagonal = [diagonal_board[i:i + 3] for i in range(0, len(diagonal_board), 3)]
    diagonal = [[f for f in element if f != pl_xo] for i, element in enumerate(perception_diagonal)]
    diagonal_ = diagonal.copy()
    positions = horizontal_ + vertical_ + diagonal_  # объединяем в базу все возможные варианты
    if pl_xo == "X":  # выбор человека
        ai_sim = "O"
    else:
        ai_sim = "X"
    for cell in positions:
        if (cell.count(ai_sim) == 2) and (len(cell) == 3):
            cell.remove(ai_sim)             # Победа в приоритете. Если ход и 2 символа наши, то ставим третий
            cell.remove(ai_sim)
            mark = [cell[0], ai_sim]
            return play_mark(mark, board)
    for cell in positions:   # тк символы противника удаляются, если длина ряда = 1, но это не наш, то защищаемся
        if (len(cell) == 1) and (ai_sim not in cell):
            mark = [cell[0], ai_sim]
            return play_mark(mark, board)
    count = []
    for cell in positions:  # смотрим куда сходил человек, складируем ряды, будем бить в один из них
        if len(cell) == 2 and (ai_sim not in cell):  # Исключаем ряды где есть и "Х", и "О" ['X', 'O', 4].
            count.append(cell)
    if (count != []) and (str(perception[1][1]) not in "XO"):  # если ходит второй, обязательный ход
        mark = [perception[1][1], ai_sim]                          # в центр иначе проигрыш при правильной игре человека
        return play_mark(mark, board)
    if count:  # если вынужденных ходов нет, и хранилище не пустое, тогда мешаем ему
        mark = [random.choice(random.choice(count)), ai_sim]  # берем рандомный ряд и не занятую позицию
        return play_mark(mark, board)
    if not count:  # Remains(остаток) отслеживает сколько чисел в поле. Хранилище пустое при 1 ходе и при явной ничье.
        remains = [[f for f in element if f != "X" if f != "O"] for i, element in enumerate(perception)]
        if len(remains[0] + remains[1] + remains[2]) == 9:
            mark = [random.choice(random.choice(diagonal)), ai_sim]  # AI в первый ход эффективнее сходить в любую
        else:                                                                               # позицию на диагоналях
            mark = [random.choice(remains[0] + remains[1] + remains[2]), ai_sim]  # ходим в любое поле из оставшихся
        return play_mark(mark, board)


# БЛОК СРАВНЕНИЯ текущих значений в матрице с выигрышными
def check_win(board):
    victory_condition = ((0, 1, 2), (3, 4, 5), (6, 7, 8), (0, 3, 6), (1, 4, 7), (2, 5, 8), (0, 4, 8), (2, 4, 6))
    for combination in victory_condition:
        if board[combination[0]] == board[combination[1]] == board[combination[2]]:
            return board[combination[0]]
    return False


def new_game():
    while True:
        restart = input("1. Новая игра\n2. Выход из игры")
        try:
            restart = int(restart)
        except ValueError:
            print("Некорректный ввод. Повторите пожалуйста")
            continue
        restart = int(restart)
        if restart > 2 or restart < 1:
            print('Некорректный ввод. Повторите пожалуйста')
            continue
        break
    if restart == 1:
        return start()
    else:
        print("Завершение работы...")


start()
'''
ИСТОЧНИКИ:
1  Основа игры крестики-нолики для pvp...http://pythonicway.com/?catid=0&id=4 (переделано) 
2. Поворот матрицы на 90 градусов https://www.cyberforum.ru/python-beginners/thread2230591.html 
'''
