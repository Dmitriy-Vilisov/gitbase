import secrets
import telebot
from telebot import types
import time

class PwdEngine:
    LOWERCASE = 'abcdefghijklmnopqrstuvwxyz'
    UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    DIGITS = '0123456789'
    PUNCTUATIONS = '!#$%&()*+-<=>?[]_{}'
    send = ['abc', 'ABC', '123']  # дефолтное значение
    lenght = 20                   # дефолтное значение

    def __init__(self, send, lenght):
        self.send = send
        self.lenght = lenght

    def get_lenght(self):
        return self.lenght

    def get_send(self):
        return self.send

    def set_send(self, send):
        if len(send) > 0:  # проверяем, что выбран хотя бы 1 набор
            self.send = send
            '''else:
            bot.send_message(message.chat.id, text=f'Вы не выбрали наборы, значения выставлены на стандартные')
            self.send = ['abc', 'ABC', '123']'''

    @staticmethod
    def pwdgen(lenght, send):
        for n, i in enumerate(send):
            # проверяем тип числа
            if i == 'abc':
                send[n] = PwdEngine.LOWERCASE
            if i == 'ABC':
                send[n] = PwdEngine.UPPERCASE
            if i == '123':
                send[n] = PwdEngine.DIGITS
            if i == '*!#':
                send[n] = PwdEngine.PUNCTUATIONS
        password_items = "".join(send)
        password = ''.join(secrets.SystemRandom().sample(password_items, lenght))
        while not PwdEngine.password_correction(password, password_items):
            password = ''.join(secrets.SystemRandom().sample(password_items, lenght))
        else:
            return password

    @staticmethod
    def password_correction(password, password_items):
        count_punctuations = 0
        count_digits = 0
        count_lowercase = 0
        count_uppercase = 0
        # for count punctuation symbols in password
        if PwdEngine.PUNCTUATIONS in password_items:        # Проверяем наличие знаков в password_items
            for symbol in password:
                if symbol in PwdEngine.PUNCTUATIONS:
                    count_punctuations += 1
        else:
            count_punctuations = round(len(password) / 4)  # Если знаков нет, делаем условие ниже выполненным
        
        if PwdEngine.DIGITS in password_items:             # Проверяем наличие чисел в password_items
            for symbol in password:
                if symbol in PwdEngine.DIGITS:
                    count_digits += 1
        else:
            count_digits = 1
        if PwdEngine.LOWERCASE and PwdEngine.UPPERCASE in password_items:  # Проверяем наличие чисел в password_items
            for symbol in password:
                if symbol in PwdEngine.LOWERCASE:
                    count_lowercase += 1
                if symbol in PwdEngine.UPPERCASE:
                    count_uppercase += 1
            # Если чисел нет, делаем условие ниже выполненным

        if (PwdEngine.LOWERCASE or PwdEngine.UPPERCASE) in password_items:
            if password[0:2] in PwdEngine.LOWERCASE + PwdEngine.UPPERCASE \
                    and (count_punctuations == round(len(password) / 4)) \
                    and (count_digits != 0):
                if (PwdEngine.LOWERCASE and PwdEngine.UPPERCASE) in password_items:
                    if count_lowercase > 0 and count_uppercase > 0:  # если и lower и upper, то они должны быть в пароле
                        return True  # иначе при длине 4-6 мог встречаться только 1 набор
                else:
                    return True
        elif password_items == PwdEngine.DIGITS:  # если выбраны только цифры - генерируем из них
            return True
        else:
            if (password[0:2] in PwdEngine.DIGITS) \
                    and (count_punctuations > 1) and (count_punctuations <= round(len(password) / 2)):
                return True  # Если невозможно поставить вначале две буквы, будут 2 цифры


bot = telebot.TeleBot("5931312481:AAEsYuxpAs4Lxt_48LxbjLIlHcjdzzPQyaA")

store_button_clicked = ['abc', 'ABC', '123']


# Блок для перехода в меню генерации с настроек
def main_menu(message):
    keyboard_1 = types.InlineKeyboardMarkup()
    callback_button_1 = types.InlineKeyboardButton(text="Кнопка1", callback_data="knopka1")
    keyboard_1.add(callback_button_1)
    return start_func(message)


# Главный блок с кнопкой генерации
@bot.message_handler(commands=['start'])
def start_func(message):
    # if message.text in '/start':
    bot.send_message(message.chat.id,
                     text=f'👋 Здравствуйте, {message.from_user.first_name}! \n\n Я умею генерировать '
                          'сложные пароли, давайте меня протестируем! 👀 ')
    kb_start_func = types.InlineKeyboardMarkup()
    btn0 = types.InlineKeyboardButton(text='Сгенерировать пароль 🚀', callback_data='btn0')
    kb_start_func.add(btn0)
    bot.send_message(message.chat.id, f'Текущая длина пароля: {PwdEngine.lenght} символов',
                     reply_markup=kb_start_func)

    @bot.callback_query_handler(func=lambda call: call.data == 'btn0')
    def check_start_func(call):
        if call.data == 'btn0':
            bot.send_message(call.message.chat.id, f"Ваш пароль:  {PwdEngine.pwdgen(PwdEngine.lenght, PwdEngine.send)}")


# Блок настроек
@bot.message_handler(commands=['settings'])
def func_settings(message):
    kb_settings = types.InlineKeyboardMarkup()
    btn6 = types.InlineKeyboardButton(text='Изменить длину пароля', callback_data='btn6')
    btn7 = types.InlineKeyboardButton(text='Изменить наборы символов', callback_data='btn7')
    btn8 = types.InlineKeyboardButton(text='Автосохранение последнего пароля', callback_data='btn8')
    btn9 = types.InlineKeyboardButton(text='Отображение подсказки о сложности', callback_data='btn9')
    btn10 = types.InlineKeyboardButton(text='Сброс настроек', callback_data='btn10')
    btn11 = types.InlineKeyboardButton(text='🔙 В главное меню', callback_data='btn11')
    kb_settings.add(btn6, btn7, btn8, btn9, btn10, btn11)
    bot.send_message(message.chat.id, '🛠 Меню настроек 🛠', reply_markup=kb_settings)

    # Подблок реакций на команды
    @bot.callback_query_handler(func=lambda call: call.data == 'btn[0-7]' or 'all_reset' or 'main')
    # ЕСЛИ ЗАДАТЬ РАЗНЫЕ УСЛОВИЯ СРАБАТЫВАНИЯ В call-реакции, ТО ВСЕ БУДЕТ РАБОТАТЬ ИСПРАВНО
    def check_start_func(call):
        if call.data == 'btn0':
            bot.send_message(call.message.chat.id, f"Ваш пароль:  {PwdEngine.pwdgen(PwdEngine.lenght, PwdEngine.send)}")
        if call.data == 'btn6':
            bot.send_message(call.message.chat.id, f'просто введите желаемую длину пароля от 4 до 65 символов!')
        elif call.data == 'btn7':
            kb_storage = types.InlineKeyboardMarkup()
            btn1 = types.InlineKeyboardButton(text='abc..', callback_data='btn1')
            btn2 = types.InlineKeyboardButton(text='ABC..', callback_data='btn2')
            btn3 = types.InlineKeyboardButton(text='123..', callback_data='btn3')
            btn4 = types.InlineKeyboardButton(text='!*#..', callback_data='btn4')
            all_reset = types.InlineKeyboardButton(text='все/ничего', callback_data='all_reset')
            btn5 = types.InlineKeyboardButton(text='Готово!', callback_data='btn5')
            kb_storage.add(btn1, btn2, btn3, btn4, all_reset, btn5)
            bot.send_message(call.message.chat.id, 'Выберете наборы символов для использования:',
                             reply_markup=kb_storage)
        elif call.data == 'btn1':
            if 'abc' not in store_button_clicked:  # добавление/удаление наборов из глобального хранилища
                store_button_clicked.append('abc')
            else:
                store_button_clicked.remove('abc')
        elif call.data == 'btn2':
            if 'ABC' not in store_button_clicked:
                store_button_clicked.append('ABC')
            else:
                store_button_clicked.remove('ABC')
        elif call.data == 'btn3':
            if '123' not in store_button_clicked:
                store_button_clicked.append('123')
            else:
                store_button_clicked.remove('123')
        elif call.data == 'btn4':
            if '*!#' not in store_button_clicked:
                store_button_clicked.append('*!#')
            else:
                store_button_clicked.remove('*!#')
        elif call.data == 'all_reset':
            if len(store_button_clicked) == 0:
                store_button_clicked.append('abc')
                store_button_clicked.append('ABC')
                store_button_clicked.append('123')
                store_button_clicked.append('*!#')
            else:
                store_button_clicked.clear()
        elif call.data == 'btn5':
            bot.send_message(call.message.chat.id, f'Выбраны следующие наборы: {", ".join(store_button_clicked)}')
            PwdEngine.send = store_button_clicked.copy()  # передача в генератор копии списка выбранных наборов

            kb_check_storage = types.InlineKeyboardMarkup(row_width=1)
            main = types.InlineKeyboardButton(text='В главное меню', callback_data='main')
            re_btn7 = types.InlineKeyboardButton(text='Изменить выбор', callback_data='btn7')
            kb_check_storage.add(main, re_btn7)
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.id,
                                  text='Выберете ''дальнейшие действия: ', reply_markup=kb_check_storage)
        elif call.data == 'main':
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                  text='вы вернулись в главное меню', reply_markup=main_menu(message))


@bot.message_handler(content_types=['text'])
def f(message):
    min_max_len = list(map(str, range(4, 66)))  # разрешенная длина пароля от 4 до 70 с.
    if message.text in min_max_len:   # Фильтрация ввода. В генератор передается только удовлетворяющее значение
        new_len_psw = min_max_len.index(message.text) + 4
        print(new_len_psw)
        bot.send_message(message.chat.id, text=f'Окей, теперь длина пароля {new_len_psw} символов!')
        PwdEngine.lenght = new_len_psw  # введенное значение длины пароля передается в генератор, заменяет стандартное


while True:
    try:
        bot.polling(none_stop=True)

    except Exception as e:
        print(e)
        time.sleep(5)
